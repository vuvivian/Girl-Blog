---
title: JavaScript基础知识
date: 2021-02-21
tags: 
	- 重学前端
---

<div style="width: 100%; font-size: 16px; color:#d4226a;  background: #f5bebe;  padding: 15px; border-radius: 4px; ">
你不必等到非常厉害，才敢开始;    你需要开始，才会变得非常厉害 。🤔️ 🤔️ 🤔️
</div>

🎈 如有补充或问题请提issues 🎏  我会及时回复~ <br />
🎈 将会持续更新，给个Star 🌟 再走吧~ 

***
> Q1:   JavaScript 基本数据类型

6中基本数据类型：`Undefined` `Null` `Boolean` `String` `Number` `Object` <br />
ES6新增：`Symbol`  <br />
ES10新增：`BigInt`  <br />

> Q2:  JavaScript 原型，原型链？ 有什么特点？

1. JS中每个函数都存在有一个原型对象属性prototype。并且所有函数的默认原型都是Object的实例。

2. 每个继承父函数的子函数的对象都包含一个内部属性_proto_。该属性包含一个指针，指向父函数的prototype。若父函数的原型对象的_proto_属性为再上一层函数。在此过程中就形成了原型链。

3. 原型链实现了继承。原型链存在两个问题：a 包含引用类型值的原型属性会被所有实例共享。b 在创建子类型时，无法向超类型的构造函数中传递参数。

在js中我们是使用构造函数来新建对象的，每个构造函数内部都有一个`prototype`属性值（这个属性值是一个对象， 这个属性值包含了该构造函数的所有实例共享的属性和方法）;
当我们使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的prototype属性对应的值，在es5中这个指针被称为对象的原型。
一般来说我们是不应该能够获取到这个值的，但是现在浏览器实现了`_proto_`属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为不是规范的。ES5中新增了一个`Object.getPrototypeOf()`方法，我们通过这个方法来获取对象的原型。

当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么就会去他的原型对象中寻找他的这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是`Object.prototype`,所以这就是我们新建的对象可以使用toString()等方法的原因。

⚠️ Javascript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本，所以当我们修改对象的原型时，与之相关的对象也会继承这一改变。


> Q3:  JavaScript 原型的获取方法


1. `p._proto_` 
2. `p.constructor.prototype`
3. `Object.getPrototypeOf(p)`

> Q4: JavaScript 继承的实现方式？

1. 原型链方式继承

```
 function Cat(){ }
 Cat.prototype = new Animal();
 Cat.prototype.name = 'cat';
```
2. 构造函数方式继承
```
 function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
}
```
3. 实例继承
```
	function Cat(name){
    var instance = new Animal();
    instance.name = name || 'Tom';
    return instance;
  }
```

4. 组合继承
4. 原型式继承
5. 寄生式继承
6. 寄生式组合继承

> Q5: Javascript创建对象有几种方式

1. 工厂模式
2. 构造函数模式
3. 原型模式
4. 组合使用构造函数和原型模式
5. 动态原型模式
6. 寄生构造函数模式

> Q6: this对象的了解

1.this是js 的一个关键字，随着函数的使用场合的不同，this 的值会发生变化。
2.一个总原则：即this指的是调用函数的那个对象。
3.一般情况下，this 是全局对象，可以作为方法调用。

this是执行上下文中的一个属性，他指向最后一次调用这个方法的对象。
在实际开发中，this的指向可以通过4种调用模式来判断：
1. 函数调用模式
2. 方法调用模式
3. 构造器调用模式
4. apply/call/bind调用模式

🐷  <span  style="font-size: 14px; color:rgb(0, 124, 255);  background: #f5bebe;  padding: 5px; border-radius: 4px; "> 优先级排序  3 > 4 > 2> 1</span>


> Q7: Javascript的作用域链本质及作用

- 本质: 一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。

- 作用：保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。

> Q8: 事件委托(事件代理)是什么

时间委托本质上是利用浏览器冒泡的机制。因为事件在冒泡的过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。

> Q9: 闭包是什么？为什么要用闭包

- 含义：闭包是指有权访问另一个函数作用域中变量的函数。创建闭包最常见的方式是在一个函数内创建另一个函数，创建的函数可以访问当前函数的局部变量。

- 用途：

> Q10 :闭包造成内存泄漏举例

> Q11 :模块化 模块循环引用  js 的几种模块规范

> Q12: DOMContentLoaded 事件和 Load 事件的区别


> Q13: EventBus


> Q14: 层叠上下文

> Q15: Js 文件异步加载

> Q16: js 延迟加载的方式有哪些

1. 给js脚本添加`defer`属性，这个属性会让脚本的加载与文档的解析同步进行，然后在文档解析完成后再执行这个脚本文件，这样可以使页面的加载不被阻塞，多个defer脚本按规范来说是**顺序**执行的，但在浏览器可能结果不是这样。
2. 给脚本添加`async`属性，这个属性会让脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行js，这时候如果没有解析完成的话同样会阻塞，多个async脚本的**执行顺序是不可预测的**。
3. `动态创建dom标签`的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态创建script标签来引入js。
4. 使用`setTimeout`延迟。
5. 将`js脚本放在文档的底部`，让js最后加载。

> Q17:  同步和异步的区别

> Q18:  call() 和 .apply() 的区别？


> Q19:  JavaScript 类数组对象的定义 常见的类数组转换为数组的方法有这样几种：

> Q20:  数组和对象有哪些原生方法，列举一下  数组的 fill 方法


> Q21:  哪些操作会造成内存泄漏

> Q22:  js 的事件循环是什么？
JavaScript 是一门单线程语言，异步操作都是放到事件循环队列里面，等待主执行栈来执行的，并没有专门的异步执行线程。

> Q23:  内部属性 [[Class]] 是什么
> Q24:  介绍 js 有哪些内置对象？
> Q25: 重绘和回流

`html 加载时发生了什么`
在页面加载时，浏览器把获取到的HTML代码解析成1个DOM树，DOM树里包含了所有HTML标签，包括display:none隐藏，还有用JS动态添加的元素等。
浏览器把所有样式(用户定义的CSS和用户代理)解析成样式结构体
DOM Tree 和样式结构体组合后构建render tree, render tree类似于DOM tree，但区别很大，因为render tree能识别样式，render tree中每个NODE都有自己的style，而且render tree不包含隐藏的节点(比如display:none的节点，还有head节点)，因为这些节点不会用于呈现，而且不会影响呈现的，所以就不会包含到 render tree中。我自己简单的理解就是DOM Tree和我们写的CSS结合在一起之后，渲染出了render tree。

`什么是回流`
当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。

`什么是重绘`
当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。

`区别：`
他们的区别很大：
回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流
当页面布局和几何属性改变时就需要回流
比如：添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变





