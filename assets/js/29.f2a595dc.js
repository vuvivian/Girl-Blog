(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{639:function(t,e,v){"use strict";v.r(e);var _=v(5),o=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("div",{staticStyle:{width:"100%","font-size":"16px",color:"#d4226a",background:"#f5bebe",padding:"15px","border-radius":"4px"}},[t._v("\n你不必等到非常厉害，才敢开始;    你需要开始，才会变得非常厉害 。🤔️ 🤔️ 🤔️\n")]),t._v(" "),v("p",[t._v("🎈 如有补充或问题请提issues 🎏  我会及时回复~ "),v("br"),t._v("\n🎈 将会持续更新，给个Star 🌟 再走吧~")]),t._v(" "),v("hr"),t._v(" "),v("blockquote",[v("p",[t._v("Q1: Vue 组件间通信")])]),t._v(" "),v("ul",[v("li",[v("p",[t._v("父子通信：")]),t._v(" "),v("ol",[v("li",[t._v("父向子传递数据是通过 props，子向父是通过$emit；")]),t._v(" "),v("li",[t._v("通过父链 / 子链也可以通信$parent / $children；")]),t._v(" "),v("li",[t._v("ref 也可以访问组件实例；")]),t._v(" "),v("li",[t._v("provide / inject API；")]),t._v(" "),v("li",[t._v("$attrs/$listeners")])])]),t._v(" "),v("li",[v("p",[t._v("兄弟通信：\nBus；Vuex")])]),t._v(" "),v("li",[v("p",[t._v("跨级通信：\nBus；Vuex；provide / inject API、$attrs/$listeners")])])]),t._v(" "),v("p",[t._v("🐷 ref 如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例")]),t._v(" "),v("blockquote",[v("p",[t._v("Q2: 双向绑定的原理")])]),t._v(" "),v("p",[t._v("VUE 双向数据绑定用到了文档碎片 "),v("code",[t._v("documentFragment")]),t._v(" "),v("code",[t._v("Object.defineProperty")]),t._v(" "),v("code",[t._v("proxy")]),t._v(" 及 "),v("code",[t._v("发布订阅模式")]),t._v("。")]),t._v(" "),v("p",[t._v("首先 Vue 会使用"),v("code",[t._v("documentfragment")]),t._v("劫持根元素里包含的所有节点，这些节点不仅包括标签元素，还包括文本，甚至换行的回车。 然后 Vue 会把 data 中所有的数据，用 defindProperty()变成 Vue 的访问器属性，这样每次修改这些数据的时候，就会触发相应属性的 get，set 方法。 接下来编译处理劫持到的 dom 节点，遍历所有节点，根据 nodeType 来判断节点类型，根据节点本身的属性（是否有 v-model 等属性）或者文本节点的内容（是否符合"+t._s(t.文本插值)+"的格式）来判断节点是否需要编译。对 v-model，绑定事件当输入的时候，改变 Vue 中的数据。对文本节点，将他作为一个观察者 watcher 放入观察者列表，当 Vue 数据改变的时候，会有一个主题对象，对列表中的观察者们发布改变的消息，观察者们再更新自己，改变节点中的显示，从而达到双向绑定的目的。\nhttps://juejin.cn/post/6844903666709708808")]),t._v(" "),v("blockquote",[v("p",[t._v("Q3: Vuex")])]),t._v(" "),v("blockquote",[v("p",[t._v("Mutation和Action的区别")])]),t._v(" "),v("p",[t._v("1、流程顺序")]),t._v(" "),v("p",[t._v("“相应视图—>修改State”拆分成两部分，视图触发Action，Action再触发Mutation。")]),t._v(" "),v("p",[t._v("2、角色定位")]),t._v(" "),v("p",[t._v("基于流程顺序，二者扮演不同的角色。")]),t._v(" "),v("p",[t._v("Mutation：专注于修改State，理论上是修改State的唯一途径。")]),t._v(" "),v("p",[t._v("Action：业务代码、异步请求。")]),t._v(" "),v("p",[t._v("3、限制")]),t._v(" "),v("p",[t._v("角色不同，二者有不同的限制。")]),t._v(" "),v("p",[t._v("Mutation：必须同步执行。")]),t._v(" "),v("p",[t._v("Action：可以异步，但不能直接操作State。")]),t._v(" "),v("blockquote",[v("p",[t._v("Q4. Computed 和 watch 的区别")])]),t._v(" "),v("ul",[v("li",[v("p",[t._v("计算属性 computed：\n· 支持缓存，只有依赖数据发生改变，才会重新进行计算\n· 不支持异步，当 computed 内有异步操作时无效，无法监听数据的变化\n· computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于 data 中声明过或者父组件传递的 props 中的数据通过计算得到的值\n· 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用 computed\n· 如果 computed 属性属性值是函数，那么默认会走 get 方法；函数的返回值就是属性的属性值；在 computed 中的，属性都有一个 get 和一个 set 方法，当数据变化时，调用 set 方法。")])]),t._v(" "),v("li",[v("p",[t._v("侦听属性 watch\n· 不支持缓存，数据变，直接会触发相应的操作。\n· watch 支持异步；监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；\n· 当一个属性发生变化时，需要执行对应的操作；一对多；\n· 监听数据必须是 data 中声明过或者父组件传递过来的 props 中的数据，当数据变化时，触发其他操作，函数有两个参数："),v("code",[t._v("immediate")]),t._v(" 组件加载立即触发回调函数执行；"),v("code",[t._v("deep")]),t._v(" deep 的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改 obj 里面任何一个属性都会触发这个监听器里的 handler.")])]),t._v(" "),v("li",[v("p",[v("img",{attrs:{src:"images/image-20210426174923587.png",alt:"image-20210426174923587"}})]),t._v(" "),v("blockquote",[v("ol",[v("li",[t._v("Vue Data 中为什么要使用函数的方式")])])])])]),t._v(" "),v("blockquote",[v("p",[t._v("vue-router 介绍")])]),t._v(" "),v("p",[t._v("https://blog.csdn.net/qq_29207823/article/details/107514576")]),t._v(" "),v("blockquote",[v("p",[t._v("v-once")])]),t._v(" "),v("blockquote",[v("p",[t._v("动态组件和 v-once 组件")])]),t._v(" "),v("p",[t._v("https://zhuanlan.zhihu.com/p/51391221")]),t._v(" "),v("blockquote",[v("p",[t._v("vue-router 和 location.href 的区别")])]),t._v(" "),v("p",[t._v("https://www.cnblogs.com/dream111/p/13520017.html")]),t._v(" "),v("blockquote",[v("p",[t._v("骨架屏")])]),t._v(" "),v("p",[t._v("http://www.360doc.com/content/20/0709/11/21412_923150401.shtml")])])}),[],!1,null,null,null);e.default=o.exports}}]);