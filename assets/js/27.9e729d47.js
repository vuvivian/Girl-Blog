(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{630:function(s,e,l){"use strict";l.r(e);var n=l(5),a=Object(n.a)({},(function(){var s=this,e=s.$createElement,l=s._self._c||e;return l("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[l("div",{staticStyle:{width:"100%","font-size":"16px",color:"#d4226a",background:"#f5bebe",padding:"15px","border-radius":"4px"}},[s._v("\n你不必等到非常厉害，才敢开始;    你需要开始，才会变得非常厉害 。🤔️ 🤔️ 🤔️\n")]),s._v(" "),l("p",[s._v("🎈 如有补充或问题请提issues 🎏  我会及时回复~ "),l("br"),s._v("\n🎈 将会持续更新，给个Star 🌟 再走吧~")]),s._v(" "),l("hr"),s._v(" "),l("blockquote",[l("p",[s._v("Q1: Webpack的构建流程")])]),s._v(" "),l("ol",[l("li",[s._v("根据配置，识别入口文件")]),s._v(" "),l("li",[s._v("逐层识别模块依赖（包括Commonjs、AMD、或ES6 的import 等，都会被识别和分析）")]),s._v(" "),l("li",[s._v("Webpack 主要工作内容就是分析代码，转换代码，编译代码，最后输出代码")]),s._v(" "),l("li",[s._v("输出最后打包后的代码")])]),s._v(" "),l("blockquote",[l("p",[s._v("Q2: Loader 和 Plugin 的差别，编写Loader 和 Plugin的思路？")])]),s._v(" "),l("ul",[l("li",[s._v("loader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中，loader 运行在打包文件之前")]),s._v(" "),l("li",[s._v("plugin 赋予了 webpack 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader 无法实现的其他事，plugins 在整个编译周期都起作用")])]),s._v(" "),l("p",[l("code",[s._v("在Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过Webpack提供的 API改变输出结果； 对于loader，实质是一个转换器，将A文件进行编译形成B文件，操作的是文件，比如将A.scss或A.less转变为B.css，单纯的文件转换过程")])]),s._v(" "),l("blockquote",[l("p",[s._v("Q3:编写Loader 的思路？")])]),s._v(" "),l("div",{staticClass:"language- line-numbers-mode"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[s._v("\t// 导出一个函数，source为webpack传递给loader的文件源内容\n  module.exports = function(source) {\n    const content = doSomeThing2JsString(source);\n    \n    // 如果 loader 配置了 options 对象，那么this.query将指向 options\n    const options = this.query;\n    \n    // 可以用作解析其他模块路径的上下文\n    console.log('this.context');\n    \n    /*\n     * this.callback 参数：\n     * error：Error | null，当 loader 出错时向外抛出一个 error\n     * content：String | Buffer，经过 loader 编译后需要导出的内容\n     * sourceMap：为方便调试生成的编译后内容的 source map\n     * ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程\n     */\n    this.callback(null, content); // 异步\n    return content; // 同步\n}\n")])]),s._v(" "),l("div",{staticClass:"line-numbers-wrapper"},[l("span",{staticClass:"line-number"},[s._v("1")]),l("br"),l("span",{staticClass:"line-number"},[s._v("2")]),l("br"),l("span",{staticClass:"line-number"},[s._v("3")]),l("br"),l("span",{staticClass:"line-number"},[s._v("4")]),l("br"),l("span",{staticClass:"line-number"},[s._v("5")]),l("br"),l("span",{staticClass:"line-number"},[s._v("6")]),l("br"),l("span",{staticClass:"line-number"},[s._v("7")]),l("br"),l("span",{staticClass:"line-number"},[s._v("8")]),l("br"),l("span",{staticClass:"line-number"},[s._v("9")]),l("br"),l("span",{staticClass:"line-number"},[s._v("10")]),l("br"),l("span",{staticClass:"line-number"},[s._v("11")]),l("br"),l("span",{staticClass:"line-number"},[s._v("12")]),l("br"),l("span",{staticClass:"line-number"},[s._v("13")]),l("br"),l("span",{staticClass:"line-number"},[s._v("14")]),l("br"),l("span",{staticClass:"line-number"},[s._v("15")]),l("br"),l("span",{staticClass:"line-number"},[s._v("16")]),l("br"),l("span",{staticClass:"line-number"},[s._v("17")]),l("br"),l("span",{staticClass:"line-number"},[s._v("18")]),l("br"),l("span",{staticClass:"line-number"},[s._v("19")]),l("br"),l("span",{staticClass:"line-number"},[s._v("20")]),l("br")])]),l("p",[s._v("一般在编写loader的过程中，保持功能单一，避免做多种功能；如less文件转换成 css文件也不是一步到位，而是 less-loader、css-loader、style-loader几个 loader的链式调用才能完成转换。")]),s._v(" "),l("blockquote",[l("p",[s._v("Q4: 编写Plugin 的思路？ Webpack常见的 plugin 解决了什么问题")])]),s._v(" "),l("p",[l("code",[s._v("如果自己要实现plugin，也需要遵循一定的规范:")])]),s._v(" "),l("ul",[l("li",[s._v("插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问compiler实例")]),s._v(" "),l("li",[s._v("传给每个插件的 compiler 和 compilation 对象都是同一个引用，因此不建议修改")]),s._v(" "),l("li",[s._v("异步的事件需要在插件处理完任务时调用回调函数通知 Webpack 进入下一个流程，不然会卡住")])]),s._v(" "),l("div",{staticClass:"language- line-numbers-mode"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[s._v("class MyPlugin {\n  // Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象\n  apply (compiler) {\n    // 找到合适的事件钩子，实现自己的插件功能\n    compiler.hooks.emit.tap('MyPlugin', compilation => {\n        // compilation: 当前打包构建流程的上下文\n        console.log(compilation);\n        // do something...\n    })\n  }\n}\n")])]),s._v(" "),l("div",{staticClass:"line-numbers-wrapper"},[l("span",{staticClass:"line-number"},[s._v("1")]),l("br"),l("span",{staticClass:"line-number"},[s._v("2")]),l("br"),l("span",{staticClass:"line-number"},[s._v("3")]),l("br"),l("span",{staticClass:"line-number"},[s._v("4")]),l("br"),l("span",{staticClass:"line-number"},[s._v("5")]),l("br"),l("span",{staticClass:"line-number"},[s._v("6")]),l("br"),l("span",{staticClass:"line-number"},[s._v("7")]),l("br"),l("span",{staticClass:"line-number"},[s._v("8")]),l("br"),l("span",{staticClass:"line-number"},[s._v("9")]),l("br"),l("span",{staticClass:"line-number"},[s._v("10")]),l("br"),l("span",{staticClass:"line-number"},[s._v("11")]),l("br")])]),l("p",[s._v("在 emit 事件发生时，代表源文件的转换和组装已经完成，可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容")]),s._v(" "),l("blockquote",[l("p",[s._v("Q5:  Webpack常见的 Loader和Plugin有哪些 ？解决了什么问题")])]),s._v(" "),l("p",[s._v("常见的"),l("code",[s._v("Loader")])]),s._v(" "),l("ol",[l("li",[s._v("style-loader: 将css添加到DOM的内联样式标签style里")]),s._v(" "),l("li",[s._v("css-loader :允许将css文件通过require的方式引入，并返回css代码")]),s._v(" "),l("li",[s._v("less-loader: 处理less")]),s._v(" "),l("li",[s._v("sass-loader: 处理sass")]),s._v(" "),l("li",[s._v("postcss-loader: 用postcss来处理CSS")]),s._v(" "),l("li",[s._v("autoprefixer-loader: 处理CSS3属性前缀，已被弃用，建议直接使用postcss")]),s._v(" "),l("li",[s._v("file-loader: 分发文件到output目录并返回相对路径")]),s._v(" "),l("li",[s._v("url-loader: 和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url")]),s._v(" "),l("li",[s._v("html-minify-loader: 压缩HTML")]),s._v(" "),l("li",[s._v("babel-loader :用babel来转换ES6文件到ES")])]),s._v(" "),l("p",[s._v("常见的"),l("code",[s._v("Plugin")])]),s._v(" "),l("ol",[l("li",[s._v("html-webpack-plugin(index.html打包)")]),s._v(" "),l("li",[s._v("uglifyjs-webpack-plugin（js代码丑化压缩）")]),s._v(" "),l("li",[s._v("webpack-dev-server(本地服务器)")]),s._v(" "),l("li",[s._v("webpack-merge(webpack.config.js抽离合并)")])]),s._v(" "),l("blockquote",[l("p",[s._v("Q6: AST是什么")])]),s._v(" "),l("p",[s._v("语法抽象树的作用：")]),s._v(" "),l("ul",[l("li",[s._v("IDE的错误提示、代码格式化、代码高亮、代码自动补全等")]),s._v(" "),l("li",[s._v("JSLint、JSHint对代码错误或风格的检查等")]),s._v(" "),l("li",[s._v("webpack、rollup进行代码打包等")]),s._v(" "),l("li",[s._v("CoffeeScript、TypeScript、JSX等转化为原生Javascript\nJS Parser解析过程主要分为以下两个步骤：")])]),s._v(" "),l("ol",[l("li",[s._v("分词：将整个代码字符串分割成最小语法单元数组")]),s._v(" "),l("li",[s._v("语法分析：在分词基础上建立分析语法单元之间的关系")])]),s._v(" "),l("blockquote",[l("p",[s._v("Q7: babel的作用")])]),s._v(" "),l("ol",[l("li",[s._v("语法转换：将新的ES语法转化为浏览器能识别的语法（babel-preset-*）")]),s._v(" "),l("li",[s._v("polyfill浏览器兼容：让低版本浏览器兼容最新版ES的API")])]),s._v(" "),l("blockquote",[l("p",[s._v("Q8: 如何收集代码依赖")])]),s._v(" "),l("blockquote",[l("p",[s._v("Q9: ES Module与CMD的区别\nhttps://juejin.cn/post/6844903983987834888")])]),s._v(" "),l("blockquote",[l("p",[s._v("Q10: Webpack Proxy工作原理？ 为什么能解决跨域")])]),s._v(" "),l("blockquote",[l("p",[s._v("Q11: Webpack的热更新是如何做到的")])]),s._v(" "),l("ul",[l("li",[s._v("HMR")])]),s._v(" "),l("blockquote",[l("p",[s._v("webpack是什么？")])]),s._v(" "),l("p",[s._v("一种前端资源构建工具，一个静态模块打包器（nodule bundle）\n前端所有资源文件（js/json/css/img…）都会作为模块处理\n它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源（bundle）")]),s._v(" "),l("p",[s._v("webpack与grunt、gulp的不同？\nwebpack中什么是chunk？什么是bundle？\nWebpack 五个核心概念分别是什么？\n有哪些常见的Loader？它们是解决什么问题的？\n有哪些常见的Plugin？它们是解决什么问题的？\nwebpack的构建流程是什么?\nwebpack的热更新是什么?\n如何利用webpack来优化前端性能？\nnpm打包时需要注意哪些？如何利用webpack来更好的构建？\nhash、chunkhash、contenthash三者的区别？")])])}),[],!1,null,null,null);e.default=a.exports}}]);