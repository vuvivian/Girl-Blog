(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{620:function(e,v,_){"use strict";_.r(v);var t=_(5),n=Object(t.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("div",{staticStyle:{width:"100%","font-size":"16px",color:"#d4226a",background:"#f5bebe",padding:"15px","border-radius":"4px"}},[e._v("\n你不必等到非常厉害，才敢开始;    你需要开始，才会变得非常厉害 。🤔️ 🤔️ 🤔️\n")]),e._v(" "),_("p",[e._v("🎈 如有补充或问题请提issues 🎏  我会及时回复~ "),_("br"),e._v("\n🎈 将会持续更新，给个Star 🌟 再走吧~")]),e._v(" "),_("hr"),e._v(" "),_("blockquote",[_("p",[e._v("Q1:   JavaScript 基本数据类型")])]),e._v(" "),_("p",[e._v("6中基本数据类型："),_("code",[e._v("Undefined")]),e._v(" "),_("code",[e._v("Null")]),e._v(" "),_("code",[e._v("Boolean")]),e._v(" "),_("code",[e._v("String")]),e._v(" "),_("code",[e._v("Number")]),e._v(" "),_("code",[e._v("Object")]),e._v(" "),_("br"),e._v("\nES6新增："),_("code",[e._v("Symbol")]),e._v(" "),_("br"),e._v("\nES10新增："),_("code",[e._v("BigInt")]),e._v(" "),_("br")]),e._v(" "),_("blockquote",[_("p",[e._v("Q2:  JavaScript 原型，原型链？ 有什么特点？")])]),e._v(" "),_("ol",[_("li",[_("p",[e._v("JS中每个函数都存在有一个原型对象属性prototype。并且所有函数的默认原型都是Object的实例。")])]),e._v(" "),_("li",[_("p",[e._v("每个继承父函数的子函数的对象都包含一个内部属性_proto_。该属性包含一个指针，指向父函数的prototype。若父函数的原型对象的_proto_属性为再上一层函数。在此过程中就形成了原型链。")])]),e._v(" "),_("li",[_("p",[e._v("原型链实现了继承。原型链存在两个问题：a 包含引用类型值的原型属性会被所有实例共享。b 在创建子类型时，无法向超类型的构造函数中传递参数。")])])]),e._v(" "),_("p",[e._v("在js中我们是使用构造函数来新建对象的，每个构造函数内部都有一个"),_("code",[e._v("prototype")]),e._v("属性值（这个属性值是一个对象， 这个属性值包含了该构造函数的所有实例共享的属性和方法）;\n当我们使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的prototype属性对应的值，在es5中这个指针被称为对象的原型。\n一般来说我们是不应该能够获取到这个值的，但是现在浏览器实现了"),_("code",[e._v("_proto_")]),e._v("属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为不是规范的。ES5中新增了一个"),_("code",[e._v("Object.getPrototypeOf()")]),e._v("方法，我们通过这个方法来获取对象的原型。")]),e._v(" "),_("p",[e._v("当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么就会去他的原型对象中寻找他的这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是"),_("code",[e._v("Object.prototype")]),e._v(",所以这就是我们新建的对象可以使用toString()等方法的原因。")]),e._v(" "),_("p",[e._v("⚠️ Javascript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本，所以当我们修改对象的原型时，与之相关的对象也会继承这一改变。")]),e._v(" "),_("blockquote",[_("p",[e._v("Q3:  JavaScript 原型的获取方法")])]),e._v(" "),_("ol",[_("li",[_("code",[e._v("p._proto_")])]),e._v(" "),_("li",[_("code",[e._v("p.constructor.prototype")])]),e._v(" "),_("li",[_("code",[e._v("Object.getPrototypeOf(p)")])])]),e._v(" "),_("blockquote",[_("p",[e._v("Q4: JavaScript 继承的实现方式？")])]),e._v(" "),_("ol",[_("li",[e._v("原型链方式继承")])]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v(" function Cat(){ }\n Cat.prototype = new Animal();\n Cat.prototype.name = 'cat';\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br"),_("span",{staticClass:"line-number"},[e._v("3")]),_("br")])]),_("ol",{attrs:{start:"2"}},[_("li",[e._v("构造函数方式继承")])]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v(" function Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br"),_("span",{staticClass:"line-number"},[e._v("3")]),_("br"),_("span",{staticClass:"line-number"},[e._v("4")]),_("br")])]),_("ol",{attrs:{start:"3"}},[_("li",[e._v("实例继承")])]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("\tfunction Cat(name){\n    var instance = new Animal();\n    instance.name = name || 'Tom';\n    return instance;\n  }\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br"),_("span",{staticClass:"line-number"},[e._v("3")]),_("br"),_("span",{staticClass:"line-number"},[e._v("4")]),_("br"),_("span",{staticClass:"line-number"},[e._v("5")]),_("br")])]),_("ol",{attrs:{start:"4"}},[_("li",[e._v("组合继承")]),e._v(" "),_("li",[e._v("原型式继承")]),e._v(" "),_("li",[e._v("寄生式继承")]),e._v(" "),_("li",[e._v("寄生式组合继承")])]),e._v(" "),_("blockquote",[_("p",[e._v("Q5: Javascript创建对象有几种方式")])]),e._v(" "),_("ol",[_("li",[e._v("工厂模式")]),e._v(" "),_("li",[e._v("构造函数模式")]),e._v(" "),_("li",[e._v("原型模式")]),e._v(" "),_("li",[e._v("组合使用构造函数和原型模式")]),e._v(" "),_("li",[e._v("动态原型模式")]),e._v(" "),_("li",[e._v("寄生构造函数模式")])]),e._v(" "),_("blockquote",[_("p",[e._v("Q6: this对象的了解")])]),e._v(" "),_("p",[e._v("1.this是js 的一个关键字，随着函数的使用场合的不同，this 的值会发生变化。\n2.一个总原则：即this指的是调用函数的那个对象。\n3.一般情况下，this 是全局对象，可以作为方法调用。")]),e._v(" "),_("p",[e._v("this是执行上下文中的一个属性，他指向最后一次调用这个方法的对象。\n在实际开发中，this的指向可以通过4种调用模式来判断：")]),e._v(" "),_("ol",[_("li",[e._v("函数调用模式")]),e._v(" "),_("li",[e._v("方法调用模式")]),e._v(" "),_("li",[e._v("构造器调用模式")]),e._v(" "),_("li",[e._v("apply/call/bind调用模式")])]),e._v(" "),_("p",[e._v("🐷  "),_("span",{staticStyle:{"font-size":"14px",color:"rgb(0, 124, 255)",background:"#f5bebe",padding:"5px","border-radius":"4px"}},[e._v(" 优先级排序  3 > 4 > 2> 1")])]),e._v(" "),_("blockquote",[_("p",[e._v("Q7: Javascript的作用域链本质及作用")])]),e._v(" "),_("ul",[_("li",[_("p",[e._v("本质: 一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。")])]),e._v(" "),_("li",[_("p",[e._v("作用：保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。")])])]),e._v(" "),_("blockquote",[_("p",[e._v("Q8: 事件委托(事件代理)是什么")])]),e._v(" "),_("p",[e._v("时间委托本质上是利用浏览器冒泡的机制。因为事件在冒泡的过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。")]),e._v(" "),_("blockquote",[_("p",[e._v("Q9: 闭包是什么？为什么要用闭包")])]),e._v(" "),_("ul",[_("li",[_("p",[e._v("含义：闭包是指有权访问另一个函数作用域中变量的函数。创建闭包最常见的方式是在一个函数内创建另一个函数，创建的函数可以访问当前函数的局部变量。")])]),e._v(" "),_("li",[_("p",[e._v("用途：")])])]),e._v(" "),_("blockquote",[_("p",[e._v("Q10 :闭包造成内存泄漏举例")])]),e._v(" "),_("blockquote",[_("p",[e._v("Q11 :模块化 模块循环引用  js 的几种模块规范")])]),e._v(" "),_("blockquote",[_("p",[e._v("Q12: DOMContentLoaded 事件和 Load 事件的区别")])]),e._v(" "),_("blockquote",[_("p",[e._v("Q13: EventBus")])]),e._v(" "),_("blockquote",[_("p",[e._v("Q14: 层叠上下文")])]),e._v(" "),_("blockquote",[_("p",[e._v("Q15: Js 文件异步加载")])]),e._v(" "),_("blockquote",[_("p",[e._v("Q16: js 延迟加载的方式有哪些")])]),e._v(" "),_("ol",[_("li",[e._v("给js脚本添加"),_("code",[e._v("defer")]),e._v("属性，这个属性会让脚本的加载与文档的解析同步进行，然后在文档解析完成后再执行这个脚本文件，这样可以使页面的加载不被阻塞，多个defer脚本按规范来说是"),_("strong",[e._v("顺序")]),e._v("执行的，但在浏览器可能结果不是这样。")]),e._v(" "),_("li",[e._v("给脚本添加"),_("code",[e._v("async")]),e._v("属性，这个属性会让脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行js，这时候如果没有解析完成的话同样会阻塞，多个async脚本的"),_("strong",[e._v("执行顺序是不可预测的")]),e._v("。")]),e._v(" "),_("li",[_("code",[e._v("动态创建dom标签")]),e._v("的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态创建script标签来引入js。")]),e._v(" "),_("li",[e._v("使用"),_("code",[e._v("setTimeout")]),e._v("延迟。")]),e._v(" "),_("li",[e._v("将"),_("code",[e._v("js脚本放在文档的底部")]),e._v("，让js最后加载。")])]),e._v(" "),_("blockquote",[_("p",[e._v("Q17:  同步和异步的区别")])]),e._v(" "),_("blockquote",[_("p",[e._v("Q18:  call() 和 .apply() 的区别？")])]),e._v(" "),_("blockquote",[_("p",[e._v("Q19:  JavaScript 类数组对象的定义 常见的类数组转换为数组的方法有这样几种：")])]),e._v(" "),_("blockquote",[_("p",[e._v("Q20:  数组和对象有哪些原生方法，列举一下  数组的 fill 方法")])]),e._v(" "),_("blockquote",[_("p",[e._v("Q21:  哪些操作会造成内存泄漏")])]),e._v(" "),_("blockquote",[_("p",[e._v("Q22:  js 的事件循环是什么？\nJavaScript 是一门单线程语言，异步操作都是放到事件循环队列里面，等待主执行栈来执行的，并没有专门的异步执行线程。")])]),e._v(" "),_("blockquote",[_("p",[e._v("Q23:  内部属性 [[Class]] 是什么\nQ24:  介绍 js 有哪些内置对象？\nQ25: 重绘和回流")])]),e._v(" "),_("p",[_("code",[e._v("html 加载时发生了什么")]),e._v("\n在页面加载时，浏览器把获取到的HTML代码解析成1个DOM树，DOM树里包含了所有HTML标签，包括display:none隐藏，还有用JS动态添加的元素等。\n浏览器把所有样式(用户定义的CSS和用户代理)解析成样式结构体\nDOM Tree 和样式结构体组合后构建render tree, render tree类似于DOM tree，但区别很大，因为render tree能识别样式，render tree中每个NODE都有自己的style，而且render tree不包含隐藏的节点(比如display:none的节点，还有head节点)，因为这些节点不会用于呈现，而且不会影响呈现的，所以就不会包含到 render tree中。我自己简单的理解就是DOM Tree和我们写的CSS结合在一起之后，渲染出了render tree。")]),e._v(" "),_("p",[_("code",[e._v("什么是回流")]),e._v("\n当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。")]),e._v(" "),_("p",[_("code",[e._v("什么是重绘")]),e._v("\n当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。")]),e._v(" "),_("p",[_("code",[e._v("区别：")]),e._v("\n他们的区别很大：\n回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流\n当页面布局和几何属性改变时就需要回流\n比如：添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变")])])}),[],!1,null,null,null);v.default=n.exports}}]);